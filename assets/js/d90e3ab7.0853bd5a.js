"use strict";(globalThis.webpackChunkrobotic_book=globalThis.webpackChunkrobotic_book||[]).push([[158],{6559:(i,n,e)=>{e.r(n),e.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"module2-digital-twin/physics-tuning","title":"Realistic Physics Tuning","description":"This chapter focuses on tuning the physics parameters of your digital twin to achieve realistic and accurate simulation results. Proper physics tuning is critical for ensuring that robot behaviors developed in simulation transfer effectively to the real world.","source":"@site/docs/module2-digital-twin/03-physics-tuning.mdx","sourceDirName":"module2-digital-twin","slug":"/module2-digital-twin/physics-tuning","permalink":"/Physical-AI-and-Humanoid-Robotics-book/docs/module2-digital-twin/physics-tuning","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/physical-ai-humanoid-book/tree/main/docs/module2-digital-twin/03-physics-tuning.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"URDF to SDF Conversion","permalink":"/Physical-AI-and-Humanoid-Robotics-book/docs/module2-digital-twin/urdf-sdf-conversion"},"next":{"title":"Sensor Simulation","permalink":"/Physical-AI-and-Humanoid-Robotics-book/docs/module2-digital-twin/sensor-simulation"}}');var r=e(4848),s=e(8453);const o={},a="Realistic Physics Tuning",c={},l=[{value:"Key Physics Parameters",id:"key-physics-parameters",level:2},{value:"Tuning Methodologies",id:"tuning-methodologies",level:2},{value:"Simulating Different Materials",id:"simulating-different-materials",level:2},{value:"Example: Tuning a Robot on Different Surfaces (Conceptual Isaac Sim Script)",id:"example-tuning-a-robot-on-different-surfaces-conceptual-isaac-sim-script",level:2},{value:"Explanation",id:"explanation",level:3},{value:"Reference",id:"reference",level:3}];function d(i){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...i.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"realistic-physics-tuning",children:"Realistic Physics Tuning"})}),"\n",(0,r.jsx)(n.p,{children:"This chapter focuses on tuning the physics parameters of your digital twin to achieve realistic and accurate simulation results. Proper physics tuning is critical for ensuring that robot behaviors developed in simulation transfer effectively to the real world."}),"\n",(0,r.jsx)(n.h2,{id:"key-physics-parameters",children:"Key Physics Parameters"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Friction"}),": Coefficients (static and dynamic) that govern contact interactions between surfaces."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Damping"}),": Resistance to motion, affecting joint and link movements."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Contact Stiffness and Damping"}),": Parameters that define how objects deform and interact upon collision."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Restitution"}),': The "bounciness" of objects upon impact.']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gravity"}),": The gravitational acceleration in the simulation environment."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"tuning-methodologies",children:"Tuning Methodologies"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"System Identification"}),": Using real-world data to determine appropriate physics parameters."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Iterative Refinement"}),": Adjusting parameters through trial and error, comparing simulation to reality."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Domain Randomization"}),": Varying physics parameters during training to improve robustness to real-world variations (covered in more detail in Module 3)."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"simulating-different-materials",children:"Simulating Different Materials"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Slippery Surfaces"}),": Low friction coefficients (e.g., wet tiles)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High-Friction Surfaces"}),": High friction coefficients (e.g., rubber)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Soft/Deformable Objects"}),": Adjusting contact parameters."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example-tuning-a-robot-on-different-surfaces-conceptual-isaac-sim-script",children:"Example: Tuning a Robot on Different Surfaces (Conceptual Isaac Sim Script)"}),"\n",(0,r.jsxs)(n.p,{children:["This conceptual Python script for NVIDIA Isaac Sim demonstrates how to load a simple robot and dynamically adjust its friction properties to simulate interaction with different virtual surfaces. We'll reference our ",(0,r.jsx)(n.code,{children:"examples/simulation_configs/physics_config.json"})," for parameters."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Conceptual Python script for Isaac Sim (not directly executable as standalone)\r\nimport omni.isaac.core as icore\r\nimport json\r\n\r\ndef setup_scene(world):\r\n    # Set up a basic scene with a ground plane\r\n    world.scene.add_default_ground_plane(\r\n        prim_path="/World/GroundPlane",\r\n        # Example of setting ground plane friction from config\r\n        # Assuming we have a default ground friction defined\r\n        static_friction=1.0, # Will be overridden if specified in config\r\n        dynamic_friction=1.0 # Will be overridden if specified in config\r\n    )\r\n\r\n    # Add a simple cuboid robot\r\n    from omni.isaac.core.objects import DynamicCuboid\r\n    robot_cuboid = world.scene.add(\r\n        DynamicCuboid(\r\n            prim_path="/World/Robot",\r\n            name="robot_cuboid",\r\n            position=icore.utils.prims.get_prim_at_path("/World/Robot").get_world_pose().p, # Example position, replace with actual\r\n            scale=icore.utils.prims.get_prim_at_path("/World/Robot").get_world_pose().s,\r\n            size=0.1,\r\n            density=1000.0, # kg/m^3\r\n        )\r\n    )\r\n    return robot_cuboid\r\n\r\ndef apply_friction(rigid_prim, static_mu, dynamic_mu):\r\n    # This is conceptual. In Isaac Sim, you\'d modify the PhysX material directly.\r\n    # For a simplified view, imagine setting these values on the prim directly.\r\n    print(f"Applying friction: Static={static_mu}, Dynamic={dynamic_mu} to {rigid_prim.name}")\r\n    # rigid_prim.set_static_friction(static_mu)\r\n    # rigid_prim.set_dynamic_friction(dynamic_mu)\r\n\r\ndef main():\r\n    # Initialize Isaac Sim (conceptual)\r\n    # icore.initialize()\r\n    # world = icore.World(stage_units_in_meters=1.0)\r\n    # robot = setup_scene(world)\r\n\r\n    print("--- Loading Physics Configurations ---")\r\n    with open("examples/simulation_configs/physics_config.json", \'r\') as f:\r\n        physics_configs = json.load(f)\r\n\r\n    # Simulate different surfaces\r\n    surfaces = {\r\n        "slippery_tiles": {"static": 0.1, "dynamic": 0.05},\r\n        "rubber_mat": physics_configs["friction_coefficients"]["rubber_on_asphalt"]\r\n    }\r\n\r\n    print("\\n--- Simulating on Slippery Tiles ---")\r\n    # apply_friction(robot, surfaces["slippery_tiles"]["static"], surfaces["slippery_tiles"]["dynamic"])\r\n    print(f"Robot would now interact with static friction: {surfaces[\'slippery_tiles\'][\'static\']} and dynamic friction: {surfaces[\'slippery_tiles\'][\'dynamic\']}")\r\n    # Run simulation step and observe behavior (e.g., increased sliding)\r\n\r\n    print("\\n--- Simulating on Rubber Mat ---")\r\n    # apply_friction(robot, surfaces["rubber_mat"]["static"], surfaces["rubber_mat"]["dynamic"])\r\n    print(f"Robot would now interact with static friction: {surfaces[\'rubber_mat\'][\'static\']} and dynamic friction: {surfaces[\'rubber_mat\'][\'dynamic\']}")\r\n    # Run simulation step and observe behavior (e.g., reduced sliding)\r\n\r\n    # icore.shutdown() # Shutdown Isaac Sim (conceptual)\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"explanation",children:"Explanation"}),"\n",(0,r.jsx)(n.p,{children:"This conceptual script demonstrates the workflow:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Loading Configuration"}),": It loads ",(0,r.jsx)(n.code,{children:"physics_config.json"})," to get predefined material properties."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scene Setup"}),": Conceptually sets up a robot in an Isaac Sim environment."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Friction Application"}),': It then simulates applying different friction coefficients (e.g., for "slippery tiles" vs. "rubber mat") to the robot\'s contact surfaces.']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Observation"}),": In a real simulation, you would run the physics engine for a few steps and observe how the robot's behavior changes (e.g., how far it slides, how easily it moves)."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"By varying these parameters and observing the simulated robot's interactions, you can tune the physics to match desired real-world behaviors."}),"\n",(0,r.jsx)(n.h3,{id:"reference",children:"Reference"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"examples/simulation_configs/physics_config.json"})}),"\n"]})]})}function u(i={}){const{wrapper:n}={...(0,s.R)(),...i.components};return n?(0,r.jsx)(n,{...i,children:(0,r.jsx)(d,{...i})}):d(i)}},8453:(i,n,e)=>{e.d(n,{R:()=>o,x:()=>a});var t=e(6540);const r={},s=t.createContext(r);function o(i){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof i?i(n):{...n,...i}},[n,i])}function a(i){let n;return n=i.disableParentContext?"function"==typeof i.components?i.components(r):i.components||r:o(i.components),t.createElement(s.Provider,{value:n},i.children)}}}]);