# ROS 2 Architecture

This chapter provides a comprehensive overview of the ROS 2 (Robot Operating System 2) architecture, its core concepts, and how it addresses the challenges of modern robotics development.

## Key Concepts

*   **DDS (Data Distribution Service)**: The middleware that enables data communication.
*   **Nodes**: Executable processes that perform computations.
*   **Topics**: Named buses for nodes to exchange messages.
*   **Services**: Request/reply mechanisms for nodes to communicate.
*   **Actions**: Long-running goal-based communication.

## Communication Patterns

*   **Publish/Subscribe**: Asynchronous, one-to-many communication.
*   **Client/Service**: Synchronous, request-response communication.
*   **Action Client/Action Server**: Asynchronous, goal-based communication for long-running tasks.

## Advantages of ROS 2

*   **Real-time capabilities**: Improved performance and predictability.
*   **Security**: Enhanced communication security with SROS 2.
*   **Distributed systems**: Better support for multi-robot and distributed deployments.
*   **Multi-platform**: Wider operating system support.

## Example: Simple Publisher-Subscriber

To demonstrate the basic publish/subscribe communication pattern in ROS 2, we will create a simple Python publisher node and a corresponding subscriber node.

### 1. Publisher Node (`minimal_publisher.py`)

This node publishes "Hello ROS 2" messages to a topic named `topic` at a rate of 2 Hz.

```python
# examples/ros2_code/minimal_publisher.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):

    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello ROS 2: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher)
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### 2. Subscriber Node (`minimal_subscriber.py`)

This node subscribes to the `topic` and prints the messages it receives.

```python
# examples/ros2_code/minimal_subscriber.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):

    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    minimal_subscriber = MinimalSubscriber()
    rclpy.spin(minimal_subscriber)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### How to Run

1.  Open two separate terminal windows.
2.  In each terminal, source your ROS 2 environment.
3.  Run the publisher:
    ```bash
    python3 examples/ros2_code/minimal_publisher.py
    ```
4.  In the other terminal, run the subscriber:
    ```bash
    python3 examples/ros2_code/minimal_subscriber.py
    ```
You should see the subscriber terminal receiving messages from the publisher.
