# Bridging External Python Agents to ROS 2 Controllers

This chapter explores how to integrate external Python applications, including advanced AI agents like Large Language Models (LLMs), with your ROS 2 robot control system. You will learn to design communication interfaces that enable high-level decision-making processes to influence real-time robot behavior.

## Why Bridge External Agents?

*   **Advanced AI**: Integrating sophisticated AI algorithms (e.g., path planning, natural language understanding).
*   **Modularity**: Decoupling complex decision-making from low-level control loops.
*   **Flexibility**: Easily swapping out different AI components without altering core robot code.

## Communication Patterns for Bridging

*   **ROS 2 Topics**: Publishing high-level goals and subscribing to robot feedback.
*   **ROS 2 Actions**: Implementing goal-based interactions for complex tasks (e.g., "move to kitchen", "pick up cup").
*   **Custom ROS 2 Interfaces**: Defining messages and services specifically for agent-robot communication.

## Example: LLM-driven Goal Setter (Conceptual Integration)

This example utilizes a simple Python agent (`examples/python_agent.py`) to simulate a high-level decision-making process (like that of an LLM). This agent publishes periodic high-level goals (e.g., "wave", "stand", "bow") to a ROS 2 topic. While a full ROS 2 Action Server implementation is outside the scope of this particular chapter, this example illustrates the communication interface.

### `examples/python_agent.py`

```python
# examples/python_agent.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimplePythonAgent(Node):
    def __init__(self):
        super().__init__('simple_python_agent')
        self.publisher_ = self.create_publisher(String, 'high_level_goals', 10)
        timer_period = 1.0  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        goals = ["wave", "stand", "bow"]
        msg.data = goals[self.i % len(goals)]
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing high-level goal: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    simple_agent = SimplePythonAgent()
    rclpy.spin(simple_agent)
    simple_agent.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### How this Integrates with a ROS 2 Action Server (Conceptual)

1.  **Agent Publishes Goal**: The `SimplePythonAgent` node publishes a `String` message containing a high-level goal (e.g., "wave") to the `/high_level_goals` topic.
2.  **Action Server Subscribes**: A dedicated ROS 2 Action Server (e.g., `humanoid_action_server`) would subscribe to `/high_level_goals`.
3.  **Action Server Processes Goal**: Upon receiving a goal, the Action Server:
    *   Parses the `String` command.
    *   Initiates a long-running action (e.g., a "Wave" action).
    *   Provides feedback to the agent (e.g., "Waving arms...").
    *   Sends a result upon completion (e.g., "Wave action completed successfully").

### How to Run the Example Agent

1.  Open a terminal and source your ROS 2 environment.
2.  Run the simple Python agent:
    ```bash
    python3 examples/python_agent.py
    ```
3.  In another terminal, you can listen to the topic to see the goals being published:
    ```bash
    ros2 topic echo /high_level_goals
    ```
You will see the `SimplePythonAgent` publishing cyclic goals, simulating an external intelligence guiding your robot.

