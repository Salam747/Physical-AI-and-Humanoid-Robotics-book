# Sim-to-Real Transfer Recipes

This chapter focuses on the critical problem of Sim-to-Real (S2R) transfer in robotics â€“ how to successfully deploy policies or behaviors learned in simulation to physical robots. You will learn practical recipes and techniques to minimize the "reality gap" and ensure your AI models perform reliably in the real world.

## The Reality Gap Revisited

*   **Sources of Discrepancy**: Differences in physics, sensor noise, latency, and hardware characteristics between simulation and reality.
*   **Impact on Performance**: Models trained in simulation often fail or degrade significantly when deployed to real robots.

## Key Sim-to-Real Techniques

*   **Domain Randomization (DR)**: (Brief recap) Randomizing simulation parameters during training to encourage robustness to real-world variations.
*   **Domain Adaptation (DA)**: Techniques that explicitly adapt models from a source domain (sim) to a target domain (real) using unpaired data.
    *   **Unsupervised Domain Adaptation**: Learning domain-invariant features.
    *   **Generative Adversarial Networks (GANs)**: Bridging the gap in appearance.
*   **System Identification**: More accurately modeling the physical properties of the real robot and environment in simulation.
*   **Curriculum Learning**: Gradually increasing the complexity of the simulation environment during training.
*   **Action Space and Observation Space Matching**: Ensuring consistency between sim and real interfaces.

## Sim-to-Real Transfer for Humanoid Robots

*   **Proprioceptive Data**: Matching joint angles, velocities, and torques.
*   **Contact Dynamics**: Fine-tuning friction and contact parameters for walking/grasping.
*   **Sensor Noise**: Accurately modeling real-world sensor imperfections.

## Example: Transferring a Grasping Policy (Conceptual Sim-to-Real Pipeline)

This conceptual example outlines a pipeline for successfully transferring a robotic grasping policy trained in simulation (e.g., Isaac Sim with Domain Randomization) to a real robot. We will refer to configuration files and scripts that conceptually represent different stages of this process.

### 1. Conceptual Sim-to-Real Pipeline (`conceptual_s2r_pipeline.py`)

```python
# Conceptual Python script for Sim-to-Real Transfer Pipeline
import json
import os
# import omni.isaac.core as icore # For simulation
# import your_robot_hardware_interface # For real robot

def configure_simulation_environment(config_path):
    """Configures the simulation environment, potentially with domain randomization."""
    print(f"Loading RL environment configuration from {config_path}")
    with open(config_path, 'r') as f:
        config = json.load(f)
    
    print(f"  Environment: {config['environment']['name']}")
    print(f"  Randomization factor: {config['environment']['randomization']['domain_rand_factor']}")
    # icore.initialize() # Initialize Isaac Sim
    # world = icore.World()
    # Apply randomization settings from config
    # return world

def train_policy_in_simulation():
    """Trains a robot policy (e.g., grasping) within the configured simulation."""
    print("Training policy in simulation (e.g., Isaac Sim) using PPO algorithm...")
    # rl_agent = PPOAgent()
    # rl_agent.train(simulation_environment)
    print("Policy training complete. Trained model: trained_policy_sim.pth")
    return "trained_policy_sim.pth"

def evaluate_sim_performance(policy_model):
    """Evaluates the trained policy's performance in simulation."""
    print(f"Evaluating policy '{policy_model}' performance in simulation...")
    # simulation_success_rate = rl_agent.evaluate(policy_model, simulation_environment)
    simulation_success_rate = 0.95 # Conceptual success rate
    print(f"Simulation success rate: {simulation_success_rate:.2f}")
    return simulation_success_rate

def perform_system_identification():
    """Performs system identification on the real robot to reduce the reality gap."""
    print("Performing system identification on real robot...")
    # Measure real robot's friction, inertia, sensor noise, etc.
    # Update simulation parameters based on real-world measurements
    print("System identification complete. Simulation parameters adjusted.")

def transfer_and_deploy_policy(policy_model):
    """Transfers the trained policy to the real robot and deploys it."""
    print(f"Transferring and deploying policy '{policy_model}' to real robot...")
    # This might involve model conversion (e.g., ONNX, TensorRT) for edge deployment
    # And then using a deployment script like sim_to_real_transfer_script.py
    
    # from examples.rl_sim_to_real import sim_to_real_transfer_script
    # sim_to_real_transfer_script.main(policy_model) # Conceptual call
    print("Policy deployed to real robot.")

def evaluate_real_performance():
    """Evaluates the deployed policy's performance on the real robot."""
    print("Evaluating real robot performance...")
    # real_success_rate = real_robot.evaluate_policy()
    real_success_rate = 0.88 # Conceptual success rate
    print(f"Real-world success rate: {real_success_rate:.2f}")
    return real_success_rate

def main():
    print("--- Conceptual Sim-to-Real Pipeline ---")
    
    # Stage 1: Configure Simulation & Train
    # sim_world = configure_simulation_environment("examples/rl_sim_to_real/rl_environment_config.yaml")
    # trained_policy = train_policy_in_simulation()
    
    # For demonstration, assume policy is trained
    trained_policy_model = "trained_policy_sim.pth" 

    # Stage 2: Evaluate Sim Performance
    sim_rate = evaluate_sim_performance(trained_policy_model)

    # Stage 3: Reduce Reality Gap & Deploy
    # perform_system_identification()
    transfer_and_deploy_policy(trained_policy_model)

    # Stage 4: Evaluate Real Performance
    real_rate = evaluate_real_performance()

    print(f"\n--- Sim-to-Real Transfer Summary ---")
    print(f"Simulation Success Rate: {sim_rate:.2f}")
    print(f"Real-world Success Rate: {real_rate:.2f}")
    print(f"Performance Drop: {(sim_rate - real_rate):.2f}")

if __name__ == '__main__':
    main()
```

### Explanation

This conceptual pipeline demonstrates the stages of a sim-to-real transfer for an RL policy:

1.  **Simulation Configuration & Training**: The `configure_simulation_environment` function conceptually sets up an Isaac Sim environment, potentially applying domain randomization as defined in `rl_environment_config.yaml`. The `train_policy_in_simulation` then represents the process of training a robot policy (e.g., for grasping) within this environment.
2.  **Simulation Evaluation**: `evaluate_sim_performance` assesses how well the policy performs in the simulated world.
3.  **Reality Gap Reduction & Deployment**: `perform_system_identification` conceptually represents a step to measure real-world physical properties and update simulation parameters to reduce discrepancies. `transfer_and_deploy_policy` then takes the trained policy and deploys it to the physical robot, often involving optimizations for edge hardware.
4.  **Real-world Evaluation**: Finally, `evaluate_real_performance` measures the policy's success rate on the actual robot.

The goal is to minimize the "Performance Drop" between simulation and reality, validating the effectiveness of the sim-to-real techniques used.

### References

*   `examples/rl_sim_to_real/rl_environment_config.yaml`
*   `examples/rl_sim_to_real/sim_to_real_transfer_script.py`
